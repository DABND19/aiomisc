# Translations template for aiomisc.
# Copyright (C) 2021
# This file is distributed under the same license as the aiomisc project.
# Dmitry Orlov <me@mosquito.su>, 2022.
msgid ""
msgstr ""
"Project-Id-Version:  14\n"
"Report-Msgid-Bugs-To: me@mosquito.su\n"
"POT-Creation-Date: 2023-04-24 12:59+0300\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dmitry Orlov <me@mosquito.su>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.12.1\n"

#: ../../source/entrypoint.rst:2
msgid "entrypoint"
msgstr "Точка входа (`entrypoint`)"

#: ../../source/entrypoint.rst:4
msgid ""
"In the generic case, the entrypoint helper creates an event loop and "
"cancels already running coroutines on exit."
msgstr ""
"В общем случае точка входа это сущность помогающая создать event loop и "
"закрыть все еще запущенные корутины при выходе."

#: ../../source/entrypoint.rst:7
msgid ""
"import asyncio\n"
"import aiomisc\n"
"\n"
"async def main():\n"
"    await asyncio.sleep(1)\n"
"\n"
"with aiomisc.entrypoint() as loop:\n"
"    loop.run_until_complete(main())"
msgstr ""

#: ../../source/entrypoint.rst:20
msgid "Complete example:"
msgstr "Пример целиком:"

#: ../../source/entrypoint.rst:22
msgid ""
"import asyncio\n"
"import aiomisc\n"
"import logging\n"
"import signal\n"
"\n"
"async def main():\n"
"    await asyncio.sleep(1)\n"
"    logging.info(\"Hello there\")\n"
"\n"
"with aiomisc.entrypoint(\n"
"    pool_size=2,\n"
"    log_level='info',\n"
"    log_format='color',                            # default when "
"\"rich\" absent\n"
"    log_buffer_size=1024,                          # default\n"
"    log_flush_interval=0.2,                        # default\n"
"    log_config=True,                               # default\n"
"    policy=asyncio.DefaultEventLoopPolicy(),       # default\n"
"    debug=False,                                   # default\n"
"    catch_signals=(signal.SIGINT, signal.SIGTERM), # default\n"
"    shutdown_timeout=60,                           # default\n"
") as loop:\n"
"    loop.run_until_complete(main())"
msgstr ""
"import asyncio\n"
"import aiomisc\n"
"import logging\n"
"\n"
"async def main():\n"
"    await asyncio.sleep(1)\n"
"    logging.info(\"Hello there\")\n"
"\n"
"with aiomisc.entrypoint(\n"
"    pool_size=2,\n"
"    log_level='info',\n"
"    log_format='color',                            # по умолчанию если "
"\"rich\" не установлен\n"
"    log_buffer_size=1024,                          # по умолчанию\n"
"    log_flush_interval=0.2,                        # по умолчанию\n"
"    log_config=True,                               # по умолчанию\n"
"    policy=asyncio.DefaultEventLoopPolicy(),       # по умолчанию\n"
"    debug=False,                                   # по умолчанию\n"
"    catch_signals=(signal.SIGINT, signal.SIGTERM), # по умолчанию\n"
"    shutdown_timeout=60,                           # по умолчанию\n"
") as loop:\n"
"    loop.run_until_complete(main())"

#: ../../source/entrypoint.rst:48
msgid "Running entrypoint from async code"
msgstr "Запуск точки входа (`entrypoint`) из асинхронного кода"

#: ../../source/entrypoint.rst:50
msgid ""
"import asyncio\n"
"import aiomisc\n"
"import logging\n"
"from aiomisc.service.periodic import PeriodicService\n"
"\n"
"log = logging.getLogger(__name__)\n"
"\n"
"class MyPeriodicService(PeriodicService):\n"
"    async def callback(self):\n"
"        log.info('Running periodic callback')\n"
"        # ...\n"
"\n"
"async def main():\n"
"    service = MyPeriodicService(interval=1, delay=0)  # once per minute\n"
"\n"
"    # returns an entrypoint instance because event-loop\n"
"    # already running and might be get via asyncio.get_event_loop()\n"
"    async with aiomisc.entrypoint(service) as ep:\n"
"        try:\n"
"            await asyncio.wait_for(ep.closing(), timeout=1)\n"
"        except asyncio.TimeoutError:\n"
"            pass\n"
"\n"
"\n"
"asyncio.run(main())"
msgstr ""
"import asyncio\n"
"import aiomisc\n"
"import logging\n"
"from aiomisc.service.periodic import PeriodicService\n"
"\n"
"log = logging.getLogger(__name__)\n"
"\n"
"class MyPeriodicService(PeriodicService):\n"
"    async def callback(self):\n"
"        log.info('Running periodic callback')\n"
"        # ...\n"
"\n"
"async def main():\n"
"    service = MyPeriodicService(interval=1, delay=0)  # once per minute\n"
"\n"
"    # вернет экземпляр entrypoint потому, что event-loop\n"
"    # уже запущен и может быть получен через asyncio.get_event_loop()\n"
"    async with aiomisc.entrypoint(service) as ep:\n"
"        try:\n"
"            await asyncio.wait_for(ep.closing(), timeout=1)\n"
"        except asyncio.TimeoutError:\n"
"            pass\n"
"\n"
"\n"
"asyncio.run(main())"

#: ../../source/entrypoint.rst:80
msgid "Dynamic running of services"
msgstr "Динамический запуск сервисов"

#: ../../source/entrypoint.rst:82
msgid ""
"Sometimes it is not enough to add services to the entrypoint at the "
"start, or it is not possible to get the service parameters before the "
"start of the event-loop. In this case it is possible to start services "
"after the event-loop has started, this feature available from version "
"``17``."
msgstr ""
"Иногда бывает недостаточно добавить сервисы в точку входа на старте или "
"нет возможности получить параметры сервиса до старта event-loop. В этом "
"случае возможен запуск сервисов после запуска событийного цикла, эта "
"функция доступна с версии ``17``."

#: ../../source/entrypoint.rst:87
msgid ""
"import asyncio\n"
"import aiomisc\n"
"import logging\n"
"\n"
"from aiomisc.service.periodic import PeriodicService\n"
"\n"
"log = logging.getLogger(__name__)\n"
"\n"
"\n"
"class MyPeriodicService(PeriodicService):\n"
"    async def callback(self):\n"
"        log.info('Running periodic callback')\n"
"\n"
"\n"
"async def add_services():\n"
"    entrypoint = aiomisc.entrypoint.get_current()\n"
"\n"
"    services = [\n"
"        MyPeriodicService(interval=2, delay=1),\n"
"        MyPeriodicService(interval=2, delay=0),\n"
"    ]\n"
"\n"
"    await entrypoint.start_services(*services)\n"
"    await asyncio.sleep(10)\n"
"    await entrypoint.stop_services(*services)\n"
"\n"
"\n"
"with aiomisc.entrypoint() as loop:\n"
"    loop.create_task(add_services())\n"
"    loop.run_forever()"
msgstr ""

#: ../../source/entrypoint.rst:122
msgid "Configuration from environment"
msgstr "Конфигурация из переменных окружения"

#: ../../source/entrypoint.rst:124
msgid "Module support configuration from environment variables:"
msgstr "Модуль поддерживает конфигурацию из переменных окружения:"

#: ../../source/entrypoint.rst:126
msgid "``AIOMISC_LOG_LEVEL`` - default logging level"
msgstr "``AIOMISC_LOG_LEVEL`` - уровень логирования по умолчанию"

#: ../../source/entrypoint.rst:127
msgid "``AIOMISC_LOG_FORMAT`` - default log format"
msgstr "``AIOMISC_LOG_FORMAT`` - формат логирования по умолчанию"

#: ../../source/entrypoint.rst:128
msgid "``AIOMISC_LOG_DATE_FORMAT`` - default logging date format"
msgstr "``AIOMISC_LOG_DATE_FORMAT`` - формат дат в логах по умолчанию"

#: ../../source/entrypoint.rst:129
msgid "``AIOMISC_LOG_CONFIG`` - should logging be configured"
msgstr "``AIOMISC_LOG_CONFIG`` - следует ли настраивать логирование"

#: ../../source/entrypoint.rst:130
msgid "``AIOMISC_LOG_FLUSH`` - interval between logs flushing from buffer"
msgstr "``AIOMISC_LOG_FLUSH`` - интервал сброса буфера логов logs"

#: ../../source/entrypoint.rst:131
msgid "``AIOMISC_LOG_BUFFERING`` - should logging be buffered"
msgstr "``AIOMISC_LOG_BUFFERING`` - следует ли включать буфферизацию логирования"

#: ../../source/entrypoint.rst:132
msgid "``AIOMISC_LOG_BUFFER_SIZE`` - maximum log buffer size"
msgstr "``AIOMISC_LOG_BUFFER_SIZE`` - максимальный размер буфера логов"

#: ../../source/entrypoint.rst:133
msgid "``AIOMISC_POOL_SIZE`` - thread pool size"
msgstr "``AIOMISC_POOL_SIZE`` - размер пула потоков"

#: ../../source/entrypoint.rst:134
msgid ""
"``AIOMISC_USE_UVLOOP`` - should use uvloop when it available, ``0`` to "
"disable"
msgstr ""
"``AIOMISC_USE_UVLOOP`` - следует ли использовать uvloop, ``0`` чтобы "
"отключить"

#: ../../source/entrypoint.rst:135
msgid ""
"``AIOMISC_SHUTDOWN_TIMEOUT`` - If, after receiving the signal, the "
"program does not terminate within this timeout, a force-exit occurs."
msgstr ""
"``AIOMISC_SHUTDOWN_TIMEOUT`` - Если после получения сигнала программа не "
"завершается в течение этого таймаута, происходит принудительный выход."

#: ../../source/entrypoint.rst:140
msgid "``run()`` shortcut"
msgstr "Функция ``run()``"

#: ../../source/entrypoint.rst:142
msgid ""
"``aiomisc.run()`` - it's the short way to create and destroy "
"``aiomisc.entrypoint``. It's very similar to ``asyncio.run()`` but handle"
" ``Service``'s and other ``entrypoint``'s kwargs."
msgstr ""
"``aiomisc.run()`` - это простой способ создать и разрушить "
"``aiomisc.entrypoint``. Это очень похоже на ``asyncio.run()`` но "
"управляет сервисами ``aiomisc.Service`` и принимает прочие аргументы "
"entrypoint."

#: ../../source/entrypoint.rst:146
msgid ""
"import asyncio\n"
"import aiomisc\n"
"\n"
"async def main():\n"
"    loop = asyncio.get_event_loop()\n"
"    now = loop.time()\n"
"    await asyncio.sleep(0.1)\n"
"    assert now < loop.time()\n"
"\n"
"\n"
"aiomisc.run(main())"
msgstr ""

#: ../../source/entrypoint.rst:162
msgid "Logging configuration"
msgstr "Конфигурация журналов"

#: ../../source/entrypoint.rst:164
msgid ""
"``entrypoint`` accepts ``log_format`` argument with a specific set of "
"formats, in which logs will be written to stderr:"
msgstr ""
"``entrypoint`` принимает аргумент ``log_format`` с определенным набором "
"форматов, в которых журналы будут записываться в stderr."

#: ../../source/entrypoint.rst:167
msgid "``stream`` - Python's default logging handler"
msgstr "``stream`` - стандартный python логгер"

#: ../../source/entrypoint.rst:168
msgid "``color`` - logging with `colorlog` module"
msgstr "``color`` - логирование через модуль ``colorlog``"

#: ../../source/entrypoint.rst:169
msgid "``json`` - json structure per each line"
msgstr "``json`` - json структура, одна на строчку"

#: ../../source/entrypoint.rst:170
msgid "``syslog`` - logging using stdlib `logging.handlers.SysLogHandler`"
msgstr "``syslog`` - ``logging.handlers.SysLogHandler`` из стандартной библиотеки"

#: ../../source/entrypoint.rst:171
msgid "``plain`` - just log messages, without date or level info"
msgstr ""
"``plain`` - просто сообщения, без даты или информации об уровне "
"логирования"

#: ../../source/entrypoint.rst:172
msgid ""
"``journald`` - available only when `logging-journald` module has been "
"installed."
msgstr ""
"``journald`` - доступно только если ``logging-journald`` модуль "
"установлен."

#: ../../source/entrypoint.rst:174
msgid ""
"``rich``/``rich_tb`` - available only when `rich` module has been "
"installed. ``rich_tb`` it's the same as ``rich`` but with fully expanded "
"tracebacks."
msgstr ""
"``rich``/``rich_tb`` - доступно только если установлен модуль ``rich``. "
"``rich_tb`` тоже самое что и ``rich`` только с подробными трейсбэками."

#: ../../source/entrypoint.rst:177
msgid ""
"Additionally, you can specify log level using ``log_level`` argument and "
"date format using ``log_date_format`` parameters."
msgstr ""
"Также вы можете настроить уровень логирования параметром ``log_level`` и "
"формат дат в логах параметром ``log_date_format``"

#: ../../source/entrypoint.rst:180
msgid ""
"An ``entrypoint`` will call ``aiomisc.log.basic_config`` function "
"implicitly using passed ``log_*`` parameters. Alternatively you can call "
"``aiomisc.log.basic_config`` function manually passing it already created"
" eventloop."
msgstr ""
"``entrypoint`` вызовет ``aiomisc.log.basic_config`` неявно используя "
"пеараметры ``log_*=``. В качестве альтернативы, вы можете вызвать "
"``aiomisc.log.basic_config`` вручную передав ей экземпляр ``eventloop``."

#: ../../source/entrypoint.rst:185
msgid ""
"However, you can configure logging earlier using "
"``aiomisc_log.basic_config``, but you will lose log buffering and "
"flushing in a separate thread. This function is what is actually called "
"during the logging configuration, the ``entrypoint`` passes a wrapper for"
" the handler there to flush it into the separate thread."
msgstr ""
"Однако вы можете настроить логирование раньше, используя "
"``aiomisc_log.basic_config``, но вы потеряете буферизацию и запись в "
"буфер отдельном потоке. Эта функция фактически вызывается во время "
"настройки ведения журнала, ``entrypoint`` передает обертку для logging "
"handler, чтобы он записывал в буфер в отдельном потоке."

#: ../../source/entrypoint.rst:191
msgid ""
"import logging\n"
"\n"
"from aiomisc_log import basic_config\n"
"\n"
"\n"
"basic_config(log_format=\"color\")\n"
"logging.info(\"Hello\")"
msgstr ""

#: ../../source/entrypoint.rst:201
msgid ""
"If you want to configure logging before the ``entrypoint`` is started, "
"for example after the arguments parsing, it is safe to configure it twice"
" (or more)."
msgstr ""
"Если вы хотите настроить ведение журнала перед запуском ``entrypoint``, "
"например, после разбора аргументов, это безопасно настроить его дважды "
"(или больше)."

#: ../../source/entrypoint.rst:205
msgid ""
"import logging\n"
"\n"
"import aiomisc\n"
"from aiomisc_log import basic_config\n"
"\n"
"\n"
"basic_config(log_format=\"color\")\n"
"logging.info(\"Hello from usual python\")\n"
"\n"
"\n"
"async def main():\n"
"    logging.info(\"Hello from async python\")\n"
"\n"
"\n"
"with aiomisc.entrypoint(log_format=\"color\") as loop:\n"
"    loop.run_until_complete(main())"
msgstr ""

#: ../../source/entrypoint.rst:225
msgid ""
"Sometimes you want to configure logging manually, the following example "
"demonstrates how to do this:"
msgstr ""
"Иногда вы хотите настроить ведение журнала самостоятельно, пример ниже "
"демонстрирует, как это сделать:"

#: ../../source/entrypoint.rst:228
#, python-format
msgid ""
"import os\n"
"import logging\n"
"from logging.handlers import RotatingFileHandler\n"
"from gzip import GzipFile\n"
"\n"
"import aiomisc\n"
"\n"
"\n"
"class GzipLogFile(GzipFile):\n"
"    def write(self, data) -> int:\n"
"        if isinstance(data, str):\n"
"            data = data.encode()\n"
"        return super().write(data)\n"
"\n"
"\n"
"class RotatingGzipFileHandler(RotatingFileHandler):\n"
"    \"\"\" Really added just for example you have to test it properly "
"\"\"\"\n"
"\n"
"    def shouldRollover(self, record):\n"
"        if not os.path.isfile(self.baseFilename):\n"
"            return False\n"
"        if self.stream is None:\n"
"            self.stream = self._open()\n"
"        return 0 < self.maxBytes < os.stat(self.baseFilename).st_size\n"
"\n"
"    def _open(self):\n"
"        return GzipLogFile(filename=self.baseFilename, mode=self.mode)\n"
"\n"
"\n"
"async def main():\n"
"    for _ in range(1_000):\n"
"        logging.info(\"Hello world\")\n"
"\n"
"\n"
"with aiomisc.entrypoint(log_config=False) as loop:\n"
"    gzip_handler = RotatingGzipFileHandler(\n"
"        \"app.log.gz\",\n"
"        # Maximum 100 files by 10 megabytes\n"
"        maxBytes=10 * 2 ** 20, backupCount=100\n"
"    )\n"
"    stream_handler = logging.StreamHandler()\n"
"\n"
"    formatter = logging.Formatter(\n"
"        \"[%(asctime)s] <%(levelname)s> \"\n"
"        \"%(filename)s:%(lineno)d (%(threadName)s): %(message)s\"\n"
"    )\n"
"\n"
"    gzip_handler.setFormatter(formatter)\n"
"    stream_handler.setFormatter(formatter)\n"
"\n"
"    logging.basicConfig(\n"
"        level=logging.INFO,\n"
"        # Wrapping all handlers in separate streams will not block the\n"
"        # event-loop even if gzip takes a long time to open the\n"
"        # file.\n"
"        handlers=map(\n"
"            aiomisc.log.wrap_logging_handler,\n"
"            (gzip_handler, stream_handler)\n"
"        )\n"
"    )\n"
"    loop.run_until_complete(main())"
msgstr ""
"import os\n"
"import logging\n"
"from logging.handlers import RotatingFileHandler\n"
"from gzip import GzipFile\n"
"\n"
"import aiomisc\n"
"\n"
"\n"
"class GzipLogFile(GzipFile):\n"
"    def write(self, data) -> int:\n"
"        if isinstance(data, str):\n"
"            data = data.encode()\n"
"        return super().write(data)\n"
"\n"
"\n"
"class RotatingGzipFileHandler(RotatingFileHandler):\n"
"    \"\"\" Really added just for example you have to test it properly "
"\"\"\"\n"
"\n"
"    def shouldRollover(self, record):\n"
"        if not os.path.isfile(self.baseFilename):\n"
"            return False\n"
"        if self.stream is None:\n"
"            self.stream = self._open()\n"
"        return 0 < self.maxBytes < os.stat(self.baseFilename).st_size\n"
"\n"
"    def _open(self):\n"
"        return GzipLogFile(filename=self.baseFilename, mode=self.mode)\n"
"\n"
"\n"
"async def main():\n"
"    for _ in range(1_000):\n"
"        logging.info(\"Hello world\")\n"
"\n"
"\n"
"with aiomisc.entrypoint(log_config=False) as loop:\n"
"    gzip_handler = RotatingGzipFileHandler(\n"
"        \"app.log.gz\",\n"
"        # Максимум 100 файлов по 10 мегабайт\n"
"        maxBytes=10 * 2 ** 20, backupCount=100\n"
"    )\n"
"    stream_handler = logging.StreamHandler()\n"
"\n"
"    formatter = logging.Formatter(\n"
"        \"[%(asctime)s] <%(levelname)s> \"\n"
"        \"%(filename)s:%(lineno)d (%(threadName)s): %(message)s\"\n"
"    )\n"
"\n"
"    gzip_handler.setFormatter(formatter)\n"
"    stream_handler.setFormatter(formatter)\n"
"\n"
"    logging.basicConfig(\n"
"        level=logging.INFO,\n"
"        # Обертывание всех обработчиков в отдельные потоки не заблокирует"
"\n"
"        # event-loop даже если gzip занимает много времени, чтобы открыть"
"\n"
"        # файл.\n"
"        handlers=map(\n"
"            aiomisc.log.wrap_logging_handler,\n"
"            (gzip_handler, stream_handler)\n"
"        )\n"
"    )\n"
"    loop.run_until_complete(main())"
